// Code generated by github.com/layotto/protoc-gen-p6 .

// Copyright 2021 Layotto Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package runtime

import (
	"context"

	"mosn.io/pkg/log"

	cryption "mosn.io/layotto/components/cryption"
	email "mosn.io/layotto/components/email"
	phone "mosn.io/layotto/components/phone"
	sms "mosn.io/layotto/components/sms"
)

type extensionComponents struct {
	cryptionService map[string]cryption.CryptionService

	emailService map[string]email.EmailService

	phoneCallService map[string]phone.PhoneCallService

	smsService map[string]sms.SmsService
}

func newExtensionComponents() *extensionComponents {
	return &extensionComponents{
		cryptionService: make(map[string]cryption.CryptionService),

		emailService: make(map[string]email.EmailService),

		phoneCallService: make(map[string]phone.PhoneCallService),

		smsService: make(map[string]sms.SmsService),
	}
}

func (m *MosnRuntime) initCryptionService(factorys ...*cryption.Factory) error {
	log.DefaultLogger.Infof("[runtime] init CryptionService")

	// 1. register all implementation
	reg := cryption.NewRegistry(m.info)
	reg.Register(factorys...)
	// 2. loop initializing
	for name, config := range m.runtimeConfig.CryptionService {
		// 2.1. create the component
		c, err := reg.Create(config.Type)
		if err != nil {
			m.errInt(err, "create the component %s failed", name)
			return err
		}
		//inject secret to component
		if config.Metadata, err = m.Injector.InjectSecretRef(config.SecretRef, config.Metadata); err != nil {
			return err
		}
		// 2.2. init
		if err := c.Init(context.TODO(), &config); err != nil {
			m.errInt(err, "init the component %s failed", name)
			return err
		}
		m.cryptionService[name] = c
	}
	return nil
}

func (m *MosnRuntime) initEmailService(factorys ...*email.Factory) error {
	log.DefaultLogger.Infof("[runtime] init EmailService")

	// 1. register all implementation
	reg := email.NewRegistry(m.info)
	reg.Register(factorys...)
	// 2. loop initializing
	for name, config := range m.runtimeConfig.EmailService {
		// 2.1. create the component
		c, err := reg.Create(config.Type)
		if err != nil {
			m.errInt(err, "create the component %s failed", name)
			return err
		}
		//inject secret to component
		if config.Metadata, err = m.Injector.InjectSecretRef(config.SecretRef, config.Metadata); err != nil {
			return err
		}
		// 2.2. init
		if err := c.Init(context.TODO(), &config); err != nil {
			m.errInt(err, "init the component %s failed", name)
			return err
		}
		m.emailService[name] = c
	}
	return nil
}

func (m *MosnRuntime) initPhoneCallService(factorys ...*phone.Factory) error {
	log.DefaultLogger.Infof("[runtime] init PhoneCallService")

	// 1. register all implementation
	reg := phone.NewRegistry(m.info)
	reg.Register(factorys...)
	// 2. loop initializing
	for name, config := range m.runtimeConfig.PhoneCallService {
		// 2.1. create the component
		c, err := reg.Create(config.Type)
		if err != nil {
			m.errInt(err, "create the component %s failed", name)
			return err
		}
		//inject secret to component
		if config.Metadata, err = m.Injector.InjectSecretRef(config.SecretRef, config.Metadata); err != nil {
			return err
		}
		// 2.2. init
		if err := c.Init(context.TODO(), &config); err != nil {
			m.errInt(err, "init the component %s failed", name)
			return err
		}
		m.phoneCallService[name] = c
	}
	return nil
}

func (m *MosnRuntime) initSmsService(factorys ...*sms.Factory) error {
	log.DefaultLogger.Infof("[runtime] init SmsService")

	// 1. register all implementation
	reg := sms.NewRegistry(m.info)
	reg.Register(factorys...)
	// 2. loop initializing
	for name, config := range m.runtimeConfig.SmsService {
		// 2.1. create the component
		c, err := reg.Create(config.Type)
		if err != nil {
			m.errInt(err, "create the component %s failed", name)
			return err
		}
		//inject secret to component
		if config.Metadata, err = m.Injector.InjectSecretRef(config.SecretRef, config.Metadata); err != nil {
			return err
		}
		// 2.2. init
		if err := c.Init(context.TODO(), &config); err != nil {
			m.errInt(err, "init the component %s failed", name)
			return err
		}
		m.smsService[name] = c
	}
	return nil
}

func (m *MosnRuntime) initExtensionComponent(s services) error {
	if err := m.initCryptionService(s.cryption...); err != nil {
		return err
	}

	if err := m.initEmailService(s.email...); err != nil {
		return err
	}

	if err := m.initPhoneCallService(s.phone...); err != nil {
		return err
	}

	if err := m.initSmsService(s.sms...); err != nil {
		return err
	}

	return nil
}
